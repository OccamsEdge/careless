if(nrow(itemPairs)==0) {
return(stop("No Psychometric Synonyms found."))
}
}
else if(anto==TRUE) {
itemPairs <- which(correlations < -critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
stop("No Psychometric Antonyms found.")
}
}
# Make a list of the item pair variable names
rowNames <- rownames(correlations) # First, collect the Row Names
colNames <- colnames(correlations) # Then the column names
matches <- matrix(nrow=nrow(itemPairs), ncol=2) # Instantiate a list to hold them all
dimnames(matches) <- list(1:nrow(itemPairs), c("xName", "yName")) #tidying up the column names
for(row in 1:nrow(itemPairs)) { # Loop to fill the list with the names of the variable pairs
matches[row,"xName"] <- rowNames[itemPairs[row,1]]
matches[row,"yName"] <- colNames[itemPairs[row,2]]
}
return(matches)
}
# Helper function to calculate the within person correlation for a single individual
synForOne <- function(data, itemPairs) {
# Looping variables
x_sum = 0
y_sum = 0
# Changed to "numeric for cross products"
cross_products <- vector(mode="numeric", length=nrow(itemPairs))
x_squares <- vector(mode="numeric", length=nrow(itemPairs))
y_squares <- vector(mode="numeric", length=nrow(itemPairs))
for (k in 1:nrow(itemPairs)) {
cross_products[k] <- data[itemPairs[k,1]]*data[itemPairs[k,2]]
x_squares[k] <- data[itemPairs[k,1]]^2
y_squares[k] <- data[itemPairs[k,2]]^2
x_sum = x_sum + data[itemPairs[k,1]]
y_sum = y_sum + data[itemPairs[k,2]]
}
sum_cp = sum(cross_products)
sum_squares_x = sum(x_squares)
sum_squares_y = sum(y_squares)
x_average = x_sum/nrow(itemPairs)
y_average = y_sum/nrow(itemPairs)
numerator = sum_cp - (nrow(itemPairs)*x_average*y_average)
d1 = sum_squares_x - (nrow(itemPairs)*(x_average^2))
d2 = sum_squares_y - (nrow(itemPairs)*(y_average^2))
denominator = sqrt(d1*d2)
if(denominator == 0){
denominator = .0000000000001
}
psychsyn = numerator/denominator
#if they put same number for all, no variance and NA is the score
return(psychsyn)
}
##################### psy.syn v0.3 ############################################################################################
# Date: 21-August-2015
# Author: Richard D. Yentes
# Contact: rdyentes@ncsu.edu
#
# Example usage: x <- psy.syn(data, .60 )
#     Returns a vector x containing the within-person correlation between responses to item pairs that are identified to be
#	correlated at > .60 within the data set.
#
#
# based off of an algorithm created by Adam W. Meade and code written by Mary Katherine Ward
##############################################################################################################################
library("Hmisc")
psy.syn <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
itemPairs <- getItemPairs(data, critVal, anto)
synonyms <- apply(data,1,synForOne, itemPairs)
return(synonyms)
}
# Helper function that identifies psychometric synonyms in a given dataset
getItemPairs <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
critVal <- abs(critVal) #Dummy Proofing
getCorr <- rcorr(data, type="pearson")
correlations <- getCorr$r
correlations[upper.tri(correlations, diag=TRUE)] <- NA
# Identifying item pairs differs depending on whether the user wants
# Psychometric Synonyms or Psychometric Antonyms
if(anto==FALSE) {
itemPairs <- which(correlations > critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
return(stop("No Psychometric Synonyms found."))
}
}
else if(anto==TRUE) {
itemPairs <- which(correlations < -critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
return(stop("No Psychometric Antonyms found."))
}
}
# Make a list of the item pair variable names
rowNames <- rownames(correlations) # First, collect the Row Names
colNames <- colnames(correlations) # Then the column names
matches <- matrix(nrow=nrow(itemPairs), ncol=2) # Instantiate a list to hold them all
dimnames(matches) <- list(1:nrow(itemPairs), c("xName", "yName")) #tidying up the column names
for(row in 1:nrow(itemPairs)) { # Loop to fill the list with the names of the variable pairs
matches[row,"xName"] <- rowNames[itemPairs[row,1]]
matches[row,"yName"] <- colNames[itemPairs[row,2]]
}
return(matches)
}
# Helper function to calculate the within person correlation for a single individual
synForOne <- function(data, itemPairs) {
# Looping variables
x_sum = 0
y_sum = 0
# Changed to "numeric for cross products"
cross_products <- vector(mode="numeric", length=nrow(itemPairs))
x_squares <- vector(mode="numeric", length=nrow(itemPairs))
y_squares <- vector(mode="numeric", length=nrow(itemPairs))
for (k in 1:nrow(itemPairs)) {
cross_products[k] <- data[itemPairs[k,1]]*data[itemPairs[k,2]]
x_squares[k] <- data[itemPairs[k,1]]^2
y_squares[k] <- data[itemPairs[k,2]]^2
x_sum = x_sum + data[itemPairs[k,1]]
y_sum = y_sum + data[itemPairs[k,2]]
}
sum_cp = sum(cross_products)
sum_squares_x = sum(x_squares)
sum_squares_y = sum(y_squares)
x_average = x_sum/nrow(itemPairs)
y_average = y_sum/nrow(itemPairs)
numerator = sum_cp - (nrow(itemPairs)*x_average*y_average)
d1 = sum_squares_x - (nrow(itemPairs)*(x_average^2))
d2 = sum_squares_y - (nrow(itemPairs)*(y_average^2))
denominator = sqrt(d1*d2)
if(denominator == 0){
denominator = .0000000000001
}
psychsyn = numerator/denominator
#if they put same number for all, no variance and NA is the score
return(psychsyn)
}
psy.syn(x,.97, TRUE)
##################### psy.syn v0.3 ############################################################################################
# Date: 21-August-2015
# Author: Richard D. Yentes
# Contact: rdyentes@ncsu.edu
#
# Example usage: x <- psy.syn(data, .60 )
#     Returns a vector x containing the within-person correlation between responses to item pairs that are identified to be
#	correlated at > .60 within the data set.
#
#
# based off of an algorithm created by Adam W. Meade and code written by Mary Katherine Ward
##############################################################################################################################
library("Hmisc")
psy.syn <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
itemPairs <- getItemPairs(data, critVal, anto)
synonyms <- apply(data,1,synForOne, itemPairs)
return(synonyms)
}
# Helper function that identifies psychometric synonyms in a given dataset
getItemPairs <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
critVal <- abs(critVal) #Dummy Proofing
getCorr <- rcorr(data, type="pearson")
correlations <- getCorr$r
correlations[upper.tri(correlations, diag=TRUE)] <- NA
# Identifying item pairs differs depending on whether the user wants
# Psychometric Synonyms or Psychometric Antonyms
if(anto==FALSE) {
itemPairs <- which(correlations > critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
return(stop("No Psychometric Synonyms found."))
}
}
else if(anto==TRUE) {
itemPairs <- which(correlations < -critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
return(stop("No Psychometric Antonyms found."))
}
}
# Make a list of the item pair variable names
rowNames <- rownames(correlations) # First, collect the Row Names
colNames <- colnames(correlations) # Then the column names
matches <- matrix(nrow=nrow(itemPairs), ncol=2) # Instantiate a list to hold them all
dimnames(matches) <- list(1:nrow(itemPairs), c("xName", "yName")) #tidying up the column names
for(row in 1:nrow(itemPairs)) { # Loop to fill the list with the names of the variable pairs
matches[row,"xName"] <- rowNames[itemPairs[row,1]]
matches[row,"yName"] <- colNames[itemPairs[row,2]]
}
return(matches)
}
# Helper function to calculate the within person correlation for a single individual
synForOne <- function(data, itemPairs) {
# Looping variables
x_sum = 0
y_sum = 0
# Changed to "numeric for cross products"
cross_products <- vector(mode="numeric", length=nrow(itemPairs))
x_squares <- vector(mode="numeric", length=nrow(itemPairs))
y_squares <- vector(mode="numeric", length=nrow(itemPairs))
for (k in 1:nrow(itemPairs)) {
cross_products[k] <- data[itemPairs[k,1]]*data[itemPairs[k,2]]
x_squares[k] <- data[itemPairs[k,1]]^2
y_squares[k] <- data[itemPairs[k,2]]^2
x_sum = x_sum + data[itemPairs[k,1]]
y_sum = y_sum + data[itemPairs[k,2]]
}
sum_cp = sum(cross_products)
sum_squares_x = sum(x_squares)
sum_squares_y = sum(y_squares)
x_average = x_sum/nrow(itemPairs)
y_average = y_sum/nrow(itemPairs)
numerator = sum_cp - (nrow(itemPairs)*x_average*y_average)
d1 = sum_squares_x - (nrow(itemPairs)*(x_average^2))
d2 = sum_squares_y - (nrow(itemPairs)*(y_average^2))
denominator = sqrt(d1*d2)
if(denominator == 0){
denominator = .0000000000001
}
psychsyn = numerator/denominator
#if they put same number for all, no variance and NA is the score
return(psychsyn)
}
psy.syn(x,.97, TRUE)
##################### psy.syn v0.3 ############################################################################################
# Date: 21-August-2015
# Author: Richard D. Yentes
# Contact: rdyentes@ncsu.edu
#
# Example usage: x <- psy.syn(data, .60 )
#     Returns a vector x containing the within-person correlation between responses to item pairs that are identified to be
#	correlated at > .60 within the data set.
#
#
# based off of an algorithm created by Adam W. Meade and code written by Mary Katherine Ward
##############################################################################################################################
library("Hmisc")
psy.syn <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
itemPairs <- getItemPairs(data, critVal, anto)
synonyms <- apply(data,1,synForOne, itemPairs)
return(synonyms)
}
# Helper function that identifies psychometric synonyms in a given dataset
getItemPairs <- function(data, critVal=.60, anto=FALSE) {
data <- as.matrix(data)
critVal <- abs(critVal) #Dummy Proofing
getCorr <- rcorr(data, type="pearson")
correlations <- getCorr$r
correlations[upper.tri(correlations, diag=TRUE)] <- NA
# Identifying item pairs differs depending on whether the user wants
# Psychometric Synonyms or Psychometric Antonyms
if(anto==FALSE) {
itemPairs <- which(correlations > critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
stop("No Psychometric Synonyms found.")
}
}
else if(anto==TRUE) {
itemPairs <- which(correlations < -critVal, arr.in=TRUE)
if(nrow(itemPairs)==0) {
stop("No Psychometric Antonyms found.")
}
}
# Make a list of the item pair variable names
rowNames <- rownames(correlations) # First, collect the Row Names
colNames <- colnames(correlations) # Then the column names
matches <- matrix(nrow=nrow(itemPairs), ncol=2) # Instantiate a list to hold them all
dimnames(matches) <- list(1:nrow(itemPairs), c("xName", "yName")) #tidying up the column names
for(row in 1:nrow(itemPairs)) { # Loop to fill the list with the names of the variable pairs
matches[row,"xName"] <- rowNames[itemPairs[row,1]]
matches[row,"yName"] <- colNames[itemPairs[row,2]]
}
return(matches)
}
# Helper function to calculate the within person correlation for a single individual
synForOne <- function(data, itemPairs) {
# Looping variables
x_sum = 0
y_sum = 0
# Changed to "numeric for cross products"
cross_products <- vector(mode="numeric", length=nrow(itemPairs))
x_squares <- vector(mode="numeric", length=nrow(itemPairs))
y_squares <- vector(mode="numeric", length=nrow(itemPairs))
for (k in 1:nrow(itemPairs)) {
cross_products[k] <- data[itemPairs[k,1]]*data[itemPairs[k,2]]
x_squares[k] <- data[itemPairs[k,1]]^2
y_squares[k] <- data[itemPairs[k,2]]^2
x_sum = x_sum + data[itemPairs[k,1]]
y_sum = y_sum + data[itemPairs[k,2]]
}
sum_cp = sum(cross_products)
sum_squares_x = sum(x_squares)
sum_squares_y = sum(y_squares)
x_average = x_sum/nrow(itemPairs)
y_average = y_sum/nrow(itemPairs)
numerator = sum_cp - (nrow(itemPairs)*x_average*y_average)
d1 = sum_squares_x - (nrow(itemPairs)*(x_average^2))
d2 = sum_squares_y - (nrow(itemPairs)*(y_average^2))
denominator = sqrt(d1*d2)
if(denominator == 0){
denominator = .0000000000001
}
psychsyn = numerator/denominator
#if they put same number for all, no variance and NA is the score
return(psychsyn)
}
psy.syn(x,.97, TRUE)
?rbinom
rbinom(5, 10, .50)
rbinom(n=5, size=10, prob=.5)
rbinom(n=5, k=10, prob=.5)
rbinom(n=5, 10, prob=.5)
?repeat
?repeat()
?repeat
;
?binomial
?rep
test <- for(i in 1:10) {
repeat(i,10)
}
for(i in 1:10) {
repeat(i,10)
}
for(i in 1:10) {
repeat(print(i),10)
}
for(i in 1:10) {
rep(print(i),10)
}
test <- for(i in 1:10) {
rep(print(i),10)
}
test
c(rep(1,10))
length <- for(i in 1:10) {
c(rep(i,10))
}
length
test
test <- for(i in 1:10) {
c(rep(i,10))
}
test
test <- c(rep(1,10))
test
test <- for(i in 1:10) {
print(i)
}
test <- for(i in 1:10) {
rep(i,10)
}
test.
test
link <- http://goo.gl/nGuVwC
link <- "http://goo.gl/nGuVwC"
length(link)
link.length
link.length()
link]
link
nchar(link)
?telnet
rm(list=ls())
rm(list=ls())
x <- c(1,2,3,4,)
x <- c(1,2,3,4,6)
x[5] <- 5
x
y <- c(c(1,2,3,4), c(1,2,3,4))
y
y <- matrix(dims=C(2,4))
?matrix
y <- matrix(data=c(1,2,3,4,5,6,7,8), nrow=2, ncol=4)
y
rbind(x,y)
?rbind
?merge
?df
?dataframe
?data_frame
??dataframe
?data.frame
x <- 1:10
d <- data.frame(x=2, y=5)
d
x <- 1:5
y <- 6:10
d <- data.frame(x=x, y=y)
d
d <- t(d)
d
rownames(d)
rownames(d) <- c(1,2)
d[1]
d
d[1,]
names(d)
names(d) <- c("v1", "v2", "v3", "v4", "v5")
names(d)
d
colnames(d)
colnames(d)d
d
colnames(d) <- names(d)
colnames(d) <- names(d)[1:5]
names(d) <- NULL
names(d)
d
x
x[3] <- NULL
x <- x[1:2,4:5]
x <- x[c(1:2,4:5)]
x
y <- y[c(1:2,4:5)]
d2 <- data.frame(1=x,2=y)
d2 <- data.frame(x=x,y=y)
d2
d2 <- t(d2)
d2
rownames(d2) <- c(1,2)
colnames(d2) <- colnames(d)[c(1:2,4:5)]
d2
rbind(d,d2)
?rbind
x <- merge(d,d2, all)
x <- merge(d,d2, all=TRUE)
x
d
d2
x <- merge(d,d2, all.y=TRUE)
x
?join
library(plyr)
rbind.fill
?rbind.fill
x <- rbind.fill(d1,d2)
x <- rbind.fill(d,d2)
d
class(d)
class(d2)
?as.df
?as.data.dframe
?as.data.frame
d <- as.data.frame
d2 <- as.data.frame(d2)
d2
class(d2)
x <- c(3,8)
d <- c(d2[,1:2], x, d2[,3:4])
d
d <- unlist(d)
d
d <- d2
d
x
d <- cbind(d, x)
d
x <- colnames(x)
x
x <- colnames(d)
d
x
x[5] <- "v3"
d
colnames(d) <- x
colnames(d)
d <- d[1:2,5,3:4]
d
d <- d2
v3 <- c(3,8)
d <- cbind(d,v3)
d
x <- d[,1:2,5,3:4]
x <- d[,c(1:2,5,3:4)]
x
class(x)
rbind.fill(x,d2)
version
install.packages("devtools")
library(devtools)
devtools::install_github("klutometis/roxygen")
library(roxygen2)
devtools::install_github("klutometis/roxygen")
install.packages("R6")
devtools::install_github("klutometis/roxygen")
devtools::install_github("klutometis/roxygen")
install_github("ryentes/careless")
library("devtools")
install_github("ryentes/careless")
getwd()
setwd("C:/Users/Wolf/Documents/Github/careless")
list.files()
devtools::document()
dat <- read.csv(sim2914.dat, header = TRUE)
dat <- read.csv("data/sim2914.dat", header = TRUE)
dat <- dat[,1:100]
colnames(dat)
str(dat)
dat <- read.table("data/sim2914.dat", header = TRUE)
dat <- dat[,1:100]
str(dat)
?save
save(dat, file="data/carelessDataset2.rda")
devtools::document()
load("data/carelessDataset.rda")
load("data/carelessDataset2.rda")
carelessDataset2 <- dat
save(carelessDataset2, file="data/carelessDataset2.rda")
devtools::document()
devtools::test()
devtools::document()
devtools::document()
devtools::document()
